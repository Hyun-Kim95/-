# 정보처리 기능사 실기 정리

## 1. 응용 SW 기초 기술 활용

* 필기 정리해 놓은 것으로 공부

## 2. 프로그래밍 언어 활용

#### 1. 알고리즘 구현

* 순서도: 논리적 절차, 흐름, 처리 방법 등을 표현, 알고리즘을 표현하는 방식 중에 가장 많이 사용됨
  * 장점: 한눈에 파악하기 쉽고, 객관적인 의사소통이 가능
  * 성능 측정: 시간과 공간을 기준으로 측정(성능이 좋은 알고리즘: 시간↓ 저장 공간↓)
  * 순서도의 기본 기호

![순서도](https://user-images.githubusercontent.com/75933619/120826770-befd4380-c595-11eb-80fc-a2cf95256363.png)

* 디버깅 표: 알고리즘(순서도)이 정확하게 작성되었는지를 최종적으로 검증하는 표

#### 2. 프로그래밍 언어 활용

* 원시 프로그램(Source Program): 사용자가 작성한 프로그램(소스 코드)

* 번역(Compile): 원시 프로그램을 번역하여 목적 프로그램을 생성

* 목적 프로그램(Object Program): 원시 프로그램이 기계어로 번역된 상태

* 링커(Linker): 재배치 형태의 기계어로 된 프로그램을 묶어서 로드 모듈로 만듬

* 로드 모듈(Load Module): 즉시 실행 가능한 프로그램

* 로더(Loader): 실행 가능한 프로그램을 보조 기억 장치에서 주 기억 장치로 읽어 와서 실행될 수 있도록 함

  * 절대 로더의 기능별 수행 주체
    * 할당/연결: 프로그래머
    * 재배치: 어셈블러
    * 적재: 로더

* 컴파일러(Compiler): 고급 언어로 작성된 원시 프로그램을 분석하여 목적 프로그램을 생성

  * 반복 작업이 빠름 -> 시간의 효율성을 중시

* 인터프리터(Interpreter): 고급 언어로 작성된 원시 프로그램 명령문들을 한 번에 한 줄 씩 읽어 들여 실행

  * 번역과 실행이 한꺼번에 이루어지기 때문에 목적 프로그램이 생성되지 않음
  * 동적인 자료 구조, 대화 형식의 프로그래밍 가능

* 하이브리드형(혼합형): 프로그램을 실행시키기 쉬운 형태로 변역 후, 디코드하여 시뮬레이션으로 실행

  * JAVA가 대표적

* 실행 방식에 따른 프로그래밍 언어의 종류

  * 명령형 언어: 폰 노이만 구조에 기초한 절차적 언어, 저수준의 기계 특성이 나타남 -> 프로그램의 정확성을 증명하기 어렵다
    * FORTRAN, COBOL, PASCAL, C, Ada 등
  * 함수형(저용형/응용) 언어
    * 순수한 함수형 언어에서는 변수가 없어도 되며 지정문, 반복문도 필요하지 않다
    * Lisp, Snobol 등
  * 논리형(선언적) 언어
    * Prolog가 대표적
  * 객체 지향 언어
    * 객체의 상호 작용에 의해 계산이 진행
    * 자료추상, 상속, 동적형 바인딩을 지원하는 언어
      * 자료추상: 자료객체의 연산들을 함께 묶어서 표현 가능, 데이터 접근을 제한 가능
      * 상속: 하위 객체가 상위 객체의 성질을 그대로 이어받는 것, 소프트웨어 재사용을 위한 기능
      * 동적형 바인딩: 상속에 융통성을 부여함으로써 다형성을 쉽게 해줌
    * Simula67, Smalltalk, C++, JAVA, C#, Python 등

* 절차적 프로그래밍 언어

  * 장점: 복잡도가 단순, 실행 속도가 빠름, 구조적 프로그램이 가능
  * 단점: 유지보수가 어려움, 프로그램 분석이 어려움, 대형 프로젝트에 부적합
  * C 언어: 고급 언어 프로그래밍과 저급 언어 프로그래밍도 가능, 시스템 프로그래밍에 가장 적합한 언어

* 객체지향 프로그래밍 언어

  > 현실 세계의 현상을 컴퓨터 상에 객체로 모델화 함으로써, 컴퓨터를 자연스러운 형태로 사용하여 여러가지 문제를 해결할 수 있는 언어
  >
  > 절차적 언어에 비해 특히 유지 보수성과 재사용성이 좋음

  * 추상화: 객체의 불필요한 부분은 숨기고 객체의 속성 중에서 가장 중요한 것에만 중점을 두고 모델화 하는 것

  * 캡슐화: 데이터와 메소드를 하나로 묶는 것으로, 객체 내부에서 필요로 하는 정보를 외부로부터 은닉시킴

  * 정보은닉: 객체 내부의 속성과 메소드를 숨기고 공개된 인터페이스를 통해서만 메시지를 주고 받을 수 있도록 하는 것을 의미

    ​					예기치 못한 Side effect를 줄이기 위해서 사용

  * 상속: 하위 객체가 상위 객체의 성질을 그대로 이어받는 것, 소프트웨어 재사용을 위한 기능, 단일상속과 다중상속이 있음

  * 다형성: 객체가 다양한 모양을 가지는 성질, 오버로딩(중복) 과 오버라이딩(재정의)

  * 장점

    > 재사용 및 시스템 확장이 용이
    >
    > 유지보수가 용이
    >
    > 대형 프로젝트에 적합
    >
    > 요구사항 변화에 안정된 프로그램 구조

  * 단점

    > 객체지향 분석 및 설계에 많은 시간이 투자됨
    >
    > 실행 속도가 절차 지향 언어에 비해 느림

  * 종류
    * C++: 클래스를 가지는 C
    * Python: 활용성이 매우 높음, 오픈 소스 소프트웨어 개발에 활용
    * Java: 썬 마이크로 시스템즈에서 개발
    * C#: C와 C++의 발전된 형태, .NET 환경에 맞춰 설계된 프로그래밍 언어

* 스크립트 언어: 다른 응용 프로그램 내에 삽입되는 언어, 스크립트 라고도 함

  * 서버용과 클라이언트용으로 구분
  * 종류: 자바스크립트, 제이쿼리, JSP, PHP, ASP, 펄, 파이썬, 루비, 브이비스크립트 등
    * Java Script: 웹페이지의 동적인 동작을 구현하는 데 사용하는 클라이언트 측 객체 기반 스크립트 언어
    * PHP: HTML 내에 작성되어 웹 페이지를 동적으로 생성하는 서버측 스크립트 언어
    * ASP: 동적 웹페이지를 만들기 위한 서버측 스크립트 언어, MS사에서 제작하여 Windows 계열 서버에서만 수행 가능
    * JSP: JAVA언어를 기반으로 만들어진 서버측 스크립트 언어
    * Python: 인터프리터형 객체지향 언어
    * jQuery: 경량의 자바스크립트 라이브러리

  * 장점

    > 문법이 비교적 쉬움
    >
    > 인터프리터형 번역 방식
    >
    > 사용자 요구에 맞게 수정이 쉬움

  * 단점

    > 실행 속도가 비교적 느림
    >
    > 실행 단계에서의 오류가 잦음

* 선언형 언어: ''무엇을 할 것인가?'에 중점을 두고 해결할 대상 문제, 자체를 서술하는 언어

  > 구체적 문제 해결 방법은 표현하지 않음
  >
  > 명령형 언어와 반대
  >
  > 유형으로는 함수형 언어와 논리형 언어가 있음

  * 함수형 언어: 적용형 언어, 수학적 함수에 적용하여 문제를 해결

    * LISP

  * 논리형 언어: 논리식을 통해 프로그램 작성

    * PROLOG

  * 장점

    > 가독성, 재사용성이 높음
    >
    > 오류 복구가 빠름
    >
    > 다른 시스템에 영향을 주지 않으므로 대체 가능성이 높음
    >
    > 참조 투명성 보장

  * 단점

    > 기존 언어를 특성화시켜 사용한 것이기 때문에 추가 및 수정이 발생할 때마다 해당 선언형 프로그램에 작업이 필요
    >
    > 설계가 잘못되었을 경우 유지보수가 복잡

  * 종류

    * LISP: 리스트 처리용 언어, 인공지능 분야에서 주로 사용
    * PROLOG: 논리 기반의 비절차적 언어, 인공지능 분양에서 주로 사용
    * HTML: 브라우저에서 동작하는 인터넷 표준 문서, 태그를 통해 웹페이지의 구조를 설계하는 단순 텍스트 기반의 정적 언어
    * XML: HTML의 기존 태그에 사용자 정의 태그(메타태그)를 추가한 인터넷 문서 표준, 웹상에서 구조화된 문서의 전송 가능한 마크업 언어
    * SQL: 관계형 데이터베이스의 데이터를 대상으로 하는 연산에 이용되는 특수 목적의 표준 언어
    * Haskell: 부작용이 없는 함수형 프로그래밍 언어

* C언어

  * 유닉스 운영체제 개발에 사용할 목적으로 만들어짐
  
  * 특징
  
    > 논리적이며 구조적인 시스템 프로그래밍 언어
    >
    > 하드웨어 제어가 가능하며 프로그램 이식성이 높음
    >
    > 간략한 문법 표현으로 함축적인 프로그램 작성이 용이
    >
    > 효율성과 유연성을 갖춘 저급 언어 특성을 가진 고급 언어
  
  * 기본 구조
  
    ![c언어 기본구조](https://user-images.githubusercontent.com/75933619/120826872-d805f480-c595-11eb-8ee6-642a11a6fedc.png)
  
* JAVA언어

  * 프로그래밍 언어와 함께 실행환경(플랫폼)을 포함

  * 특징

    > 플랫폼 독립적
    >
    > 상속을 지원하는 객체지향 프로그래밍 언어
    >
    > 응용 프로그래밍과 웹 프로그래밍(애플릿)이 가능
    >
    > 예외 처리와 멀티 스레싱을 지원

  * 기본 구조(println: 자동 줄바꿈, print: 줄바꿈X)

    ![java 기본구조](https://user-images.githubusercontent.com/75933619/120826941-e7853d80-c595-11eb-800b-de5a1ce0f99e.png)

* 데이터 타입(Data Type, 자료형): 변수가 가질 수 있는 데이터(값)의 유형

  * 기본 데이터 타입: 정해진 구조 외에 다른 구조를 가질 수 없는 자료형

    * 논리형(Boolean Type): C언어의 기본 데이터 타입은 아님, 참값(true)과 거짓값(false)의 상수를 표현
    * 문자형(Character Type): 단일 문자의 자료형, 작은 따옴표로 표현
    * 정수형(Integer Type, Fixed Point Type): 고정 소수점 타입, 정수 상수를 표현
    * 실수형(Floating Point Type): 부동 소수점 타입, 실수 상수를 표현

  * 구조적 데이터 타입: 기본 자료형으로부터 파생하여 만든 자료형

    * 배열(Array): 동일한 유형의 값들을 모아 놓은 자료형, 순차 구조, 첨자(index)로 배열 원소를 구별, 다차원 구조로 구성 가능

    * 레코드(Record): 다른 유형의 값들을 모아 놓은 자료형, 이름으로 원소를 구별

    * 포인터형(Pointer)

      > 객체를 참조하기 위해 메모리의 주소를 값으로 하는 자료형
      >
      > 하나의 자료에 많은 리스트의 연결이 가능
      >
      > 커다란 배열의 원소를 효율적으로 저장하고자 할 때 이용
      >
      > 고급 언어에서 주로 사용되는 기법
      >
      > 지원 언어: C, C++

    * 문자열형(Character String Type): 큰따옴표로 표현된 상수들을 표현, 기본 데이터 타입이 아님

* 기본 데이터 타입의 크기

  * C언어

    | 자료형  |        예약어(크기, byte)        |
    | :-----: | :------------------------------: |
    | 정수형  |  int(4), short, long, unsinged   |
    | 실수형  | float(4), double(8), long double |
    | 문자형  |    **char(1)**, unsinged char    |
    | 형 없음 |               void               |

  * JAVA

    | 자료형 |                 8가지 예약어(크기, byte)                  |
    | :----: | :-------------------------------------------------------: |
    | 정수형 | byte(1), short(2), int(4), long(8), **char(2)** <- 문자형 |
    | 실수형 |                    float(4), double(8)                    |
    | 논리형 |                        boolean(1)                         |

* 프로그램: 주어진 문제를 해결하기 위한 처리 절차와 방법을 기술한 명령어들의 모임, 자료+명령어

* 상수: 항상 고정된 값을 갖는 자료(값)로 변경이 불가능

* 변수: 프로그램 실행 중 변경할 수 있는 값이 저장되는 기억공간(=메모리)

* 바인딩(binding): 변수의 명칭과 그 메모리 주소, 데이터형 또는 실제 값을 연결하는 것

  * 정적 바인딩(번역시간), 동적 바인딩(실행시간)

* scanf(): 콘솔 화면에서 키보드로부터 자료를 주어진 입력 형식으로 입력 시키는 함수

  * scanf("%d", &Age);

* C언어 연산자 우선순위와 결합 방향

  ![c언어 연산자](https://user-images.githubusercontent.com/75933619/120827022-fa980d80-c595-11eb-8c10-c7a37a74a578.png)

* JAVA 연산자 우선순위와 결합 방향

  ![java 연산자](https://user-images.githubusercontent.com/75933619/120827075-071c6600-c596-11eb-9ee4-d857367402e0.png)

* 이항 연산자의 우선순위

  * 괄호 -> 산술 연산자 -> 비트shift연산자 -> 관계(비교) 연산자 -> 비트논리연산자 -> 논리 연산자

    ​												<<, >>												      & -> ^ -> |

* 삼항 연산자(조건 연산자): C언어와 JAVA에서 피연산자가 3개 필요한 연산자는 삼항 연산자가 유일

  * A ? B : C

    > A가 참이면 B를, 거짓이면 C를 결과값으로 설정

* 비트 연산자

  * 비트 시프트 연산자

    * `<<` 비트를 왼쪽으로 이동
    * `>>`비트를 오른쪽으로 이동

  * 비트 논리 연산자

    * &: 논리곱(AND)

      > ex) a=5; b=3; c=a&b;
      >
      > 0101 AND 0011 의 결과인 1(=0001)이 c에 저장됨

    * ^: 베티적 논리합(XOR)

      > ex) a=5; b=3; c=a^b;
      >
      > 결과: 6(=0110)

    * |: 논리합(OR)

      > ex) a=5; b=3; c=a|b;
      >
      > 결과: 7(=0111)

* 기타 연산자
  * sizeof 연산자
    * C언어에서 변수, 변수형, 배열의 저장 장소의 크기를 Byte 단위로 구함
  * 콤마 연산자
    * 성격이 동일한 자료형을 나열
    * int a, b, c;
  * Cast 연산자(형 변환 연산자)
    * 명시적 형 변환 시에 사용
  * 포인터 연산자
    * C언어의 단항연산자 중 &은 변수의 주소를 의미하고, *은 변수의 내용을 의미
    * int a = 3; int *prt = &a;

* C언어의 데이터 입출력 변환 문자

  | 종류 |              설명              |
  | :--: | :----------------------------: |
  |  %d  |   10진 정수로 변환(decimal)    |
  |  %o  |     8진 정수로 변환(octal)     |
  |  %x  | 16진 정수로 변환(hexa-decimal) |
  |  %c  |  단일 문자로 변환(character)   |
  |  %s  |     문자열로 변환(string)      |
  |  %f  |     실수형으로 변환(float)     |

* C언어 확장 문자(이스케이프 시퀀스)

  | 문자 |      의미       |             설명             |
  | :--: | :-------------: | :--------------------------: |
  |  \n  |    New Line     | 커서를 다음 줄 처음으로 이동 |
  |  \r  | Carriage Return | 커서를 현재 줄 처음으로 이동 |
  |  \t  |       Tab       |  커서를 일정 간격만큼 띄움   |
  |  \b  |    Backspace    |    커서를 뒤로 한 칸 이동    |
  |  \0  |      Null       |         널 문자 출력         |
  | \\'  |  Single Quote   |       작은 따옴표 출력       |
  | \\"  |  Double Quote   |        큰 따옴표 출력        |
  | \\\  |    Backslash    |       역슬래시(/)출력        |
  |  \a  |      Alert      |         벨소리 발생          |
  |  \f  |    Form Feed    |        한 페이지 넘김        |

* 구조적 프로그램

  * 기본 구조: 순차 구조, 선택 구조, 반복 구조
  * 가독성이 좋음, 개발 및 유지보수가 용이
  * 프로그래밍에 대한 규칙을 제공하여 투자되는 노력과 시간이 감소
  * 프로그램의 신뢰성이 향상

* 제어문: 프로그램의 흐름을 지시하는 데 사용되는 문장

* if~else문

  ```c
  if(조건식1) {
  	문장1;
  } else if(조건식2) {
  	문장2;
  } else {
      문장3;
  }
  ```

* switch~case문: 값이 일치하는 case부터 마지막까지 수행, default: case에서 찾지 못한 경우 수행

  ```c
  switch(정수형 변수){
      case 값1: 문장1;
      case 값2: 문장2;
      ...
      case 값n: 문장n;
      default: 문장x;
  }
  ```

* while문: 처음부터 조건식이 거짓이면 한번도 수행되지 않음

  ```c
  while(조건식){
      반복할 명령문들;
  }
  ```

* do~while문: 반복할 문장을 무조건 먼저 수행한 후 조건식 검사

  ```c
  do{
      반복할 명령문들;
  } while(조건식);
  ```

* for문

  ```c
  for(초기식; 조건식; 증감식)
  {
      반복할 명령문들;
  }
  ```

* goto문: 레이블이 있는 곳으로 무조건 분기

  * 장점: 루틴의 빠른 실행
  * 단점: 프로그램이 비구조적이 되고 이해하기 어려워짐
  * 구조적 프로그래밍에서는 goto문을 사용하지 않음
  * C언어에는 존재하지만, JAVA언어에는 존재하지 않는 제어문

* C언어의 문자열 배열은 문자 배열보다 1byte의 널문자('\\0')를 더 포함하고 있음

* C언어의 문자 상수의 경우는 1byte의 char 자료형으로 문자형 변수에 저장된다. 이때 문자 상수는 ASCII코드로 표현

* C언어와 JAVA언어 배열

  * C언어에서의 배열은 int, char형과 같은 기본형 상수들을 배열 변수의 인덱스를 통해 참조
  * JAVA언어에서의 배열은 참조형 변수를 통해 배열 객체를 참조

* JAVA 배열의 선언 규칙

  * 배열은 선언한 뒤 초기화나 배열 객체 생성 후, 사용 가능

  * 배열의 크기를 지정할 수 없음

  * 다차원 배열은 255차원까지 가능

    ```java
    {
        int a[] = {1,2,3};
        int[] a = {1,2,3};
        int[] a = new int[3];
    }
    ```

* Java 배열의 크기: 배열이름.length를 통해 배열의 크기인 요소의 개수를 알 수 있음

* String 클래스

  * java.lang 패키지의 주요 클래스 중의 하나

  * 주로 문자열을 출력하거나 결합하는데 사용

  * "문자열" 간 결합이 용이

    > ex) String str = new String("정보처리 한방 합격!")
    >
    > ex) System.out.println(name + "님 합격을 축하합니다!")

* String 클래스의 주요 메서드

  |                주요 메서드                 |              설명              |
  | :----------------------------------------: | :----------------------------: |
  |             char charAt(index)             |  인덱스 위치의 문자 하나 리턴  |
  |         boolean equals(Objectobj)          |    다른 문자열 객체와 비교     |
  | String replace(char oldChar, char newChar) | 특정 문자를 새로운 문자로 치환 |
  |         staticString valueOf(para)         |    숫자값을 문자형으로 처리    |
  |                int length()                |   문자열의 길이(널문자 제외)   |

* C언어의 포인터 선언

  > int *p;(= int\* p;)
  >
  > num = 100;
  >
  > p = \&num;

* 부프로그램(subprogram)

  * 주프로그램이나 다른 부프로그램에서 사용되는 독립된 형태의 단위 프로그램
  * C언어에서는 사용자 정의 함수를 통해 필요한 기능을 독립적인 단위로 구현하여 사용할 수 있도록 정의한 후 호출하여 사용
  * 부프로그램을 선언할 때 부프로그램의 이름, 부프로그램의 존재를 나타내는 키워드, 인자, 반환값, 부프로그램에서 수행하는 기능이 필요
  * 부프로그램을 사용하면 프로그램의 크기가 줄어들고, 프로그램 수정이나 관리가 편리함
  * 코루틴: 두 모듈이 같이 실행되면서 서로 호출하는 형태
  * C언어의 매개변수 전달 방법은 값호출과 참조호출만 가능

* 프로그래밍 언어의 유해 요소

  * 별명(Alias)
  * 부작용(Side Effect)

* C언어의 사용자 정의 함수

  * 선언문 -> 정의 -> 호출

    ```c
    #include <stdio.h>
    int add(int, int);
    int add(int x, int y)
    {
        int sum;
        sum = x + y;
        return sum;
    }
    int main()
    {
        printf("10 + 20 = %d\n", add(10,20));
        return 0;
    }
    ```

* JAVA 클래스와 메소드

  * 클래스: 객체를 생성하기 위한 설계 또는 틀, 필드(멤버 변수)와 메소드(멤버 함수)와 생성자로 구성됨
    * 모든 클래스에는 생성자가 반드시 존재하고 하나 이상의 생성자를 가질 수 있음, 생성자를 생략하면 컴파일 시 자동으로 기본 생성자를 추가
    * 클래스명은 대문자로 시작하며 '$'와 '_' 외에는 특수문자를 사용할 수 없음
    * 여러 개의 class 작성이 가능하지만 public class는 한 개만 가능하고 public class가 있는 경우 반드시 클래스명을 파일명으로 지정
    * 접근지정자: private < 디폴트(생략) < protected < public 순으로 공개 범위가 넓음

* 메소드 오버로딩

  * 매개 변수의 타입이나 개수가 다른 여러 개의 메소드가 샅은 이름으로 작성되는 것

* 상속

  * 자식 class는 부모 class의 생성자와 private 요소를 제외한 모든 멤버를 상속 받음

  * JAVA언어에서는 단일 상속만 가능, 자식 class는 단 하나만의 부모 class를 상속 받을 수 있음

  * 모든 class는 Object class를 상속 받음

    ```java
    class A{		// 부모 class
        필드
        메소드()
    }
    class B extends A{	// 자식 class
    }
    ```

* 오버라이딩

  * 상속 받은 멤버의 내용을 수정하여 자식 class 객체에서 적용
  * 부모 class의 정의에는 영향을 주지 않고 상속 받은 자식 class의 메소드 멤버를 재정의하는 다형성을 오버라이딩 이라 함

* 라이브러리: 애플리케이션 개발을 위해 사용되는 함수들의 모음

  * 구성 요소: 도움말, 설치 파일, 샘플 코드

* 라이브러리의 구분

  * 정적 라이브러리
    * 컴파일의 링킹단계에서 실행 파일에 결합되는 라이브러리
    * 라이브러리 변경 시, 변경된 라이브러리만 재배포하면 안되고 프로그램을 다시 재배포해야 함
    * *.a, *.lib
  * 동적 라이브러리
    * 런타임 시에 함수가 실행 파일에 연결되는 라이브러리
    * 프로그램 변경 시 변경된 부분의 공유 라이브러리만 재배포하면 되므로 유지 보수 용이
    * *.so, *.dll

* 라이브러리의 종류

  * 표준 라이브러리: 언어가 기본적으로 내장하고 있는 라이브러리
    * 별도의 파일 설치 불필요
  * 외부 라이브러리: 인터넷 등을 통해 공유 받아 사용 가능
    * 별도의 파일 설치 필요

* 모듈: 하나의 기능이 한 개의 파일로 구현된 형태

* 패키지: 여러 개의 모듈들을 한 개의 폴더(디렉토리)로 모아 놓은 형태

* 프로그래밍 언어별 표준 라이브러리

  |  구분  |                             설명                             |
  | :----: | :----------------------------------------------------------: |
  | C언어  |                    include <헤더파일명.h>                    |
  |  JAVA  |                  import 패키지명.클래스명;                   |
  |  C++   |      include <헤더파일명><br />ex)  include <iostream\>      |
  | Python | import 모듈명<br />from 모듈명 import 함수명<br />ex)  import math |

* C언어의 표준 라이브러리

  | 헤더파일 |                          함수 기능                           |                        대표 함수                        |
  | :------: | :----------------------------------------------------------: | :-----------------------------------------------------: |
  | stdio.h  | 입력 장치와 출력 장치를 통한 입출력 기능 및 파일 입출력 기능 | printf(), scanf(), putchar(), puts(), getchar(), gets() |
  | string.h |                 문자열 처리에 사용되는 기능                  |              strlen(), strcmp(), strcpy()               |
  |  math.h  |                        수학 관련 기능                        |                  sqrt(), abs(), pow()                   |
  | stdlib.h |   동적 메모리 관리 기능, 난수 발생 기능, 자료형 변환 기능    |       malloc(), calloc(), free(), rand(), atoi()        |
  |  time.h  |                   시간 처리와 관련된 기능                    |                     time(), clock()                     |

* JAVA언어의 표준 라이브러리: JAVA의 표준 라이브러리는 API 문서를 통해 확인할 수 있음

  |  Package  |                            Class                             |                            Method                            |
  | :-------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
  | java.lang |      Object 클래스: 모든 자바의 클래스의 최상위 클래스       | toString, equals, hashCode, clone, finalize, getClass, notify, notifyAll, wait |
  |           | String 클래스: 문자열을 값으로 갖고, 문자열을 조작하는 클래스 | length, substring, split, contains, endsWith, equals, replace, toString, valueOf, toLowerCase, toUpperCase |
  |           | System 클래스: JVM이 실행되는 기반 운영체제와 관련된 콘솔 입출력, 프로세스 관리하는 클래스 |            print, println, printf, format, write             |
  |           | Wrapper(래퍼) 클래스: 8개의 기본 자료형의 객체를 갖는 클래스 | Byte 클래스(byte), Short 클래스(short), Integer 클래스(integer), Long 클래스(long), Character 클래스(character), Double 클래스(double), Float 클래스(float), Boolean 클래스(boolean) |
  | java.util | Arrays 클래스: 배열의 복사, 정렬, 검색 등을 처리하는 클래스  | equals, setAll, fill, sort, stream, asList, toString, copyOf, binarySerch |
  |           | Scanner 클래스: 콘솔로부터 기본 데이터 타입 입력을 위한 클래스 |   next, nextLine, nextInt, nextDouble, charAt, hasNextInt    |
  |  java.io  |           키보드, 파일 등 입출력과 관련된 클래스들           |                                                              |
  | java.net  |                  네트워크와 관련된 클래스들                  |                                                              |
  | java.sql  |           데이터베이스 프로그래밍과 관련된 클래스            |                                                              |

* 예외

  * 사용자의 잘못된 조작이나 개발자의 잘못된 구현으로 프로그램의 오동작이나 결과에 악영향을 미치는 오류(에러가 아님)

    * 에러: 문법에 맞지 않게 작성된 코드 또는 컴퓨터 하드웨어의 오동작이나 고장으로 인해 방생

  * 예외처리를 통해 정상적인 동작을 하도록 만들 수 있음(예외란 프로그램에서 제어할 수 있는 실행시간의 오류)

  * java에서는 try~catch 구문을 통해 수행 가능

    ```java
    try{
        // 예외가 발생할 가능성이 있는 명령문;
    } catch(Exception e){
        // 예외 처리
    } finally{
        // 예외의 유무와 상관없이 실행하는 명령문;
        // 생략 가능
    }
    ```

* JAVA의 주요 예외 클래스

  |          예외 클래스           |                        예외 발생 이유                        |
  | :----------------------------: | :----------------------------------------------------------: |
  |      ArithmeticException       |                    정수를 0으로 나눌 경우                    |
  | ArrayIndexOutOfBoundsException |            배열의 범위를 벗어난 index에 접근할 시            |
  |       ClassCastException       |            변환할 수 없는 타입으로 객체를 반환 시            |
  |       NullPointException       |              존재하지 않는 레퍼런스를 참조할 때              |
  |    IllegalArgumentException    |                   잘못된 인자를 전달할 때                    |
  |          IOException           |              입출력 동작 실패 또는 인터럽트 시               |
  |      OutOfMemoryException      |                     메모리가 부족한 경우                     |
  |     NumberFormatException      | 문자열이 나타내는 숫자와 일치하지 않는 타입의 숫자로 변환 시 |

## 3. 애플리케이션 테스트 수행

#### 1. 애플리케이션 테스트 수행

* 소프트웨어 테스트

  * 개발된 소프트웨어의 결함과 문제를 식별하고 품질을 평가하며 품질을 개선하기 위한 일련의 활동

* ISTQB에서 제시하는 테스트 7 가지 원리

  * 테스트는 결함이 존재함을 밝히는 활동
  * 완벽한 테스트는 불가능
  * 테스트는 개발 초기에 시작
  * 결함 집중
    * 결함의 80%는 코드의 20%에 집중되어 있음(파레토 법칙)
  * Pesticide Paradox(살충제 패러독스)
    * 같은 테스트 케이스로 계속 테스트하면 내성으로 인해 결국은 버그가 발견되지 않음
    * 테스터가 적극적인 자세로 지속적으로 테스트 케이스를 검토하고 개정해야 함
  * 테스트는 정황(context)에 의존적
    * 대상에 따라 다르게 수행되어야 함
  * 오류-부재의 궤변
    * 사용자 요구 사항을 충족시키지 못하면 결함을 모두 제거했어도 품질이 높다고 볼 수 없음

* 요르돈 법칙(=Snowball Effec, 눈덩이 법칙)

  * 소프트웨어 개발 초기 체계적인 분석 및 설계가 수행되지 못하면 그 결과가 프로젝트 후반에 영향을 미치게 되어 비용이 커진다는 법칙

* V-모델

  * 소프트웨어 개발 생명 주기에 따라 대응되는 테스트를 표현한 다이어그램
  * 각 단계별로 나와야 하는 산출물이 정의되어 있음

* 프로젝트 수행 단계에 따른 테스트의 분류

  * '단위 테스트 -> 통합 테스트 -> 시스템 테스트 -> 인수 테스트' 순서로 테스트 진행

  * 단위 테스트: 작은 소프트웨어 단위(컴포넌트 또는 모듈)를 테스트하느 것, 일반적으로 개발자 자신에 의해 행해짐

    | 테스트 방법 |                             설명                             |                         테스트 목적                          |
    | :---------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
    |  구조 기반  | 프로그램 내부 구조 및 복잡도를 검증하는 화이트박스 테스트<br />업무 단위별 제어 흐름과 조건 결정에 따른 결과를 테스트하는 데 목적 |                     제어 흐름, 조건 결정                     |
    |  명세 기반  | 목적 및 실행 코드 기반의 실행을 통한 블랙박스 테스트<br />동등 분할과 경계 값 분석을 위하여 사용자의 입력, 출력, 내부, 이벤트 등을 확인하는 데 목적 | 동등 분할, 경계 값 분석, 결정 테이블 테스팅<br />, 상태 전이 테스팅, 유즈케이스 테스팅 |

  * 통합 테스트

    * 통합된 컴포넌트 간의 상호 작용을 테스트, 하나의 프로세스가 완성된 경우 부분적으로 통합 테스트를 수행하는 경우도 있음
    * 프로그램이 설계 단계에서 제시한 애플리케이션과 동일한 구조와 기능으로 구현된 것 인지를 확인
    * 운영체제(OS), 파일 시스템, 하드웨어 또는 시스템 간 인터페이스와 같은 각각 다른 부분과 상호 연동이 정상적으로 작동하는지 여부를 테스트
    * 종류: 빅뱅, 상향, 하향, 샌드위치, Central, Collaboration, 레이어 통합 등
    * 점증적 방식
      * 모든 컴포넌트를 사전에 통합하여 전체 프로그램을 한꺼번에 테스트
    * 비점증적 방식
      * 하향식 통합
        * 메인 제어 모듈에 통합되는 하위 모듈과 최하위 모듈인 '깊이-우선' 또는 '너비-우선' 방식으로 통합
        * 메인 제어 모듈은 작성된 프로그램을 사용하고, 더미 모듈인 **스텁(Stub)**을 개발함
        * 하위 모듈인 스텁이 한 번에 하나씩 실제 모듈로 대체 됨
        * 테스트과 완료되면 스텁이 실제 모듈 또는 컴포넌트로 작성됨
      * 상향식 통합
        * 최하위 레벨의 모듈 또는 컴포넌트들이 하위 모듈의 기능을 수행하는 클러스터로 결합
        * 더미 모듈인 **드라이버**를 작성
        * 각 통합된 클러스터 단위를 테스트
        * 테스트가 완료되면 각 클러스터들은 프로그램의 위쪽으로 결합, 드라이버는 실제 모듈 또는 컴포넌트로 대체

  * 시스템 테스트: 성능 및 장애 테스트

    * 컴퓨터 시스템을 완벽하게 검사하기 위한 목적 또는 성능 목표를 가지고 테스트

    * 실제의 최종 사용자 환경과 유사하게 테스트

    * 요구 사항 명세서, 비즈니스 절차, 유스케이스, 리스트 분석 결과 등을 이용

      |    테스트 방법     |                             설명                             |
      | :----------------: | :----------------------------------------------------------: |
      |  기능적 요구 사항  | 요구 사항 명세서, 비즈니스 절차, 유스케이스 등 명세서 기반의 블랙박스 테스트 시행 |
      | 비기능적 요구 사항 | 성능 테스트, 회복 테스트, 보안 테스트, 내부 시스템의 메뉴 구조, 웹 페이지의 네비게이션<br /> 등의 구조적 요소에 대한 화이트박스 테스트 시행 |

  * 인수 테스트: 개발된 제품에 대해 운영 여부를 결정하는 테스트, 실제 업무 적용 전에 수행

    * 종류: 사용자 인수 테스트, 운영상의 인수 테스트, 계약 인수 테스트, 규정 인수 테스트, 알파 테스트, 베타 테스트

    | 테스트 방법 |                             설명                             |
    | :---------: | :----------------------------------------------------------: |
    | 알파 테스트 | 특정 사용자들에 의해 개발자 관점에서 수행, 개발자는 사용상의 문제를 기록하여 반영되도록 하는 테스트 |
    | 베타 테스트 | 선정된 다수의 사용자가 자신들의 사용 환경에서 일정 기간 사용해 보면서 문제점이나 개선 사항 등을<br /> 기록하고 개발 조직에 통보하여 반영되도록 하는 테스트 |

  * 설치 테스트

    * 파일의 분배나 적재, 하드웨어 구성, 소프트웨어 구성, 타 소프트웨어와의 연결 문제 등을 평가

* 소프트웨어 테스트 프로세스

  * 테스트 계획 -> 테스트 분석 및 디자인 -> 테스트 케이스 및 시나리오 작성 -> 테스트 수행 -> 테스트 결과 평가 및 리포팅 -> 결함 종료

* 테스트 케이스

  * 설계된 입력 값, 실행 조건, 기대 결과로 구성된 테스트 항목의 명세서
  * 정확성, 재사용성, 간결성이 보장되어야 함

* 테스트 시나리오

  * 테스트 케이스의 집합, 테스트 케이스의 동작 순서를 기술한 문서, 테스트를 위한 절차를 명세한 문서
  * 테스트 항목을 하나의 시나리오에 모두 작성하지 않음
  * 포함 항목: 식별자 번호, 순서 번호, 테스트 데이터, 테스트 케이스, 예상 결과, 확인 등

* 테스트 오라클

  * 테스트의 결과가 참인지 판단하기 위해서 사전에 정의된 참(True) 값을 입력하여 비교하는 기법 및 활동
  * 참(True) 오라클은 주로 국방, 의료, 반도체, 항공기, 임베디드, 발전소 소프트웨어 등 미션 크리티컬한 업무에 적용
    * 미션 크리티컬한 업무: 절대로 다운되어서는 안 되는 가장 중요한 시스템
  * 샘플링/추정 오라클은 일반, 업무용, 게임, 오락 등의 일반적인 업무에 적용

  |          오라클 유형           |                             설명                             |
  | :----------------------------: | :----------------------------------------------------------: |
  |        참(True) 오라클         | 모든 입력 값에 대하여 기대하는 결과를 생성함으로써 발생한 오류를 모두 검출 할 수 있는 오라클 |
  |    샘플링(Sampling) 오라클     | 특정한 몇 개의 입력 값에 대해서만 기대하는 결과를 제공해 주는 오라클 |
  |   휴리스틱(Heuristic) 오라클   | 샘플링 오라클을 개선한 오라클로, 특정 입력 값에 대해 올바른 결과를 제공하고<br />, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클 |
  | 일관성 검사(Consistent) 오라클 | 애플리케이션 변경이 있을 때, 수행 전과 후의 결과 값이 동일한지 확인하는 오라클 |

* 테스트 자동화

  * 자동화 도구를 활용하여 준비, 구현, 수행, 분석 등을 스크립트 형태로 구현함으로써, 시간과 인력 투입의 부담을 최소화하면서 운영 중인 시스템의 모니터링 또는 UI가 없느 서비스의 경우에도 정밀한 테스트가 가능하도록 하는 것
  * 테스트 자동화 도구
    * 장점
    
      * 반복 작업의 자동화를 통하여 테스트 인력과 시간을 최소화 함
      * 향상된 요구 사항 정의, 성능 및 스트레스 테스트, 품질 측정을 최적화
    
    * 단점
    
      * 테스트 도구 전문가를 양성 또는 고용이 필요
      * 초기에 프로세스 적용에 대한 시간, 비용, 노력에 대한 추가 투자가 필요
      * 비공개 상용 소프트웨어의 경우 고가이며, 인력과 교육에 대한 유지 관리 비용이 높음
    
    * 테스트 단계 별 테스트 자동화 도구
    
      |   테스트 활동    |    테스트 도구     |                             설명                             |
      | :--------------: | :----------------: | :----------------------------------------------------------: |
      |   테스트 계획    |   요구 사항 관리   |            고객 요구 사항 정의 및 변경 사항 관리             |
      | 테스트 분석/설계 | 테스트 케이스 생성 |       테스트 기법에 따른 테스트 데이터 및 케이스 작성        |
      |                  |   커버리지 분석    |          대상 시스템에 대한 테스트 완료 범위의 척도          |
      |   테스트 수행    |   테스트 자동화    | 기능 테스트 등 테스트 도구를 활용하여 자동화를 통한 테스트의 효율성 제고 |
      |                  |     정적 분석      |               코딩 표준, 런타임 오류 등을 검증               |
      |                  |     동적 분석      |           대상 시스템 시뮬레이션을 통한 오류 검출            |
      |                  |    성능 테스트     |   가상 사용자를 인위적으로 생성하여 시스템 처리 능력 측정    |
      |                  |      모니터링      |  시스템 자원(CPU, Memory 등)의 상태 확인 및 분석 지원 도구   |
      |   테스트 통제    |     형상 관리      |       테스트 수행에 필요한 다양한 도구 및 데이터 관리        |
      |                  |    테스트 관리     |           전반적인 테스트 계획 및 활동에 대한 관리           |
      |                  |   결함 추적/관리   |           테스트에서 발생한 결함 관리 및 협업 지원           |
  
* 결함(Defect, Fault, Bug)

  * 테스트 실행 활동의 결과물로 프로그램과 명세서 간의 차이, 업무 내용 불일치를 말함
  * 시스템이 사용자가 기대하는 타당한 기대치를 만족시키지 못할 때 변경이 필요한 모든 것은 결함으로 취급

* 인시던트: 이슈와 동일한 개념, 테스트 결과 발견한 결함을 포함한 기획의도, 개선사항 등을 포함

* 결함 관리(Defect Management) 프로세스

  * 결함 관리 계획
  * 결함 기록: 테스터는 발견된 결함에 대한 정보를 결함 관리 데이터베이스에 기록
  * 결함 검토
  * 결함 수정
  * 결함 재확인
  * 결함 상태 추적 및 모니터링 활동: 결함 관리 팀장은 결함 관리 데이터베이스를 이용하여 대시보드 또는 게시판 형태의 서비스를 제공
  * 최종 결함 분석 및 보고서 작성

* 결함 보고서의 주요 항목

  > 결함 콘텍스트, 결함 설명, 심각도, 우선순위, 위험 분석, 결함 상태

* 결함 추적 보고서의 주요 항목

  > 결함 검토 정보, 결함 해결 정보, 결함 해결 검증 정보

* 결함 생명 주기: 테스트를 통해 등록(발견,Open)된 후 종료(종결, Closed)될 때까지

  * 결함 등록(Open): 테스터와 품질 관리(QA) 담당자에 의해 결함이 처음 발견되어 등록
  * 결함 검토(Reviewed): 등록된 결함을 담당 모듈 개발자, 테스터, 프로그램 리더, 품질 관리(QA) 담당자와 검토**하는** 상태
  * 결함 할당(Assigned): 결함의 영향 분석 및 수정을 위해 개발자와 문제 해결 담당자에게 할당된 상태
  * 결함 수정(Resolved): 개발자에 의해 결함의 수정이 완료된 상태
  * 결함 수정 검증(Verified): 결함 수정 처리가 합당하고 정확한지 검증된 상태, 검증 결과에 따라 결함 종료, 조치 보류, 재오픈 상태로 다음 상태가 결정됨
  * 결함 조치 보류(Deferred): 수정이 필요한 결함이지만 현재 수정이 불가능해서 연기된 상태, 우선순위와 일정 등을 고려하여 재오픈을 준비하는 상태
  * 결함 종료(Closed): 테스터와 품질 관리(QA) 담당자에 의해 종료 승인을 한 상태
  * 결함 해제(Clarified): 테스터, 프로그램 리더, 품질 관리(QA) 담당자가 결함이 아니라고 판명한 경우

* 결함 분류 4가지

  |    구분     |                             설명                             |                          결함 경우                           |
  | :---------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
  | 시스템 결함 | 비정상적인 종료/중단, 응답 시간 지연, 데이터베이스 에러 등<br /> 주로 애플리케이션 환경과 데이터베이스 처리에서 발생하는 결함 | -응용 프로그램의 비정상적인 종료/중단<br />-응답 시간 지연<br />-데이터베이스 에러 |
  |  기능 결함  | 사용자의 요구사항 미반영/불일치, 부정확한 비즈니스 프로세스, 스크립트 에러<br />, 타 시스템 연동 시 오류 등 기획, 설계, 업무 시나리오 단계에서 발생하는 결함 | -요구사항 미반영/불일치<br />-부정확한 비즈니스 프로세스<br />-웹 브라우저에서의 스크립트 에러<br />-타 시스템 연동 시 오류 |
  |  GUI 결함   | 응용 프로그램의 UI 비일관성, 부정확한 커서/메시지<br />, 데이터 타입의 표시 오류 등으로 사용자 화면 설계에서 발생하는 결함 | -응용 프로그램 UI 표준 비일관성<br />-탭 시퀀스의 부정확한 커서/메시지<br />-데이터 타입의 표시 오류 |
  |  문서 결함  | 기획자, 사용자, 개발자 간의 의사소통과 기록이 원활하지 못한 경우에 발생하는 결함 | -사용자의 온라인/오프라인 매뉴얼의 불일치<br />-요구사항 분석서와 기능 요구사항의 불일치로 인한 불완전한 상태의 문서 |

* 결함 심각도

  |  레벨  |                             설명                             |
  | :----: | :----------------------------------------------------------: |
  |  High  | -시스템이 중단(또는 다운)되어 더 이상 프로세스를 진행할 수 없게 만드는 결함 상황<br />-ex) 시스템의 핵심 요구사항 미구현, 시스템 다운, 장시간 시스템 응답 지연, 시스템 복구 후 데이터 왜곡 등 |
  | Medium | -시스템의 흐름에 영향을 미치는 결함<br />-ex) 부정확한 기능, 부정확한 업무 프로세스, 데이터 필드 형식의 오류, 데이터베이스 에러, 보안 관련 오류 등 |
  |  Low   | -시스템의 흐름에는 영향을 미치지 않는 결함이나 상황에 맞지 않는 용도와 화면 구성(Configuration) 결함<br />-ex) 부정확한 GUI 및 메시지, 에러 시 메시지 미출력, 화면상의 문법/철자 오류 등 |

* 결함 우선순위

  * 심각도가 높아도 우선순위가 반드시 높지는 않음, 애플리케이션의 특성에 따라 우선순위가 결정될 수 있음

* 결함 관리 도구

  > Mantis, Trac, Redmine, Bugzilla, QC, Clear Quest, JIRA 등

#### 2. 애플리케이션 결함 조치

* 소프트웨어 테스트 기법

  * 단위 테스트 기법: 컴포넌트나 모듈
    * JUnit을 활용한 테스트: Java 환경이라면 대부분 JUint이라는 단위 테스트 프레임워크를 통해 단위 테스트를 할 수 있어야 함
    * Mock 테스트 기법: Mock 객체를 사용, 응답 결과를 미리 정의해 놓고 테스트, 개발 완료되지 않은 상태에서도 가능
  * 통합 테스트 기법: 업무 간의 연계성과 상호 운영성 중심
  * 시스템 테스트 기법
    * 부하 및 성능 테스트, 장애 복구 테스트, 보안 테스트
  * 인수 테스트 기법: 고객이 주도하는 테스트

* 결함 관련 용어

  * 에러(Error)
    * 부정확한 결과
    * 개발자의 실수로 발생한 오타, 개발 명세서의 잘못된 이해, 서브루틴의 기능 오해 등
  * 오류(Fault)
    * 프로그램 코드 상에 존재하는 것
    * 비정상적인 프로그램과 정상적인 프로그램 **버전 간의 차이**로 인하여 발생
    * 잘못된 연산자가 사용된 경우에 프로그램이 서브루틴으로부터의 에러 리턴을 점검하는 코드가 누락된 것
  * 실패(Failure)
    * 정상적인 프로그램과 비정상적인 프로그램의 **실행 결과의 차이**
    * 프로그램의 실제 실행 결과를 개발 명세서에 정의된 예상 결과와 비교함으로써 발견
  * 결함(Defect)
    * 버그, 에러, 오류, 실패, 프로그램 실행에 대한 문제점, 프로그램 개선 사항 등의 전체를 포괄하는 용어

* 결함의 판단 기준

  * 기능 명세서에 가능하다고 명시된 동작을 수행하지 않는 경우
  * 기능 명세서에 불가능하다고 명시된 동작을 수행하는 경우
  * 기능 명세서에 명시되어 있지 않은 동작을 수행하는 경우
  * 기능 명세서에 명시되어 있지 않지만 수행해야 할 동작을 수행하지 않는 경우
  * 테스터의 시각에서 볼 때 문제가 있다고 판단되는 경우
    * 이해하기 어려운 기능
    * 사용이 까다로운 기능
    * 비정상적으로 느린 기능 등

* 테스트 격언(Testing Axioms)

  1. 소프트웨어를 완벽하게 테스트하는 것은 불가능하다.
  2. 소프트웨어 테스트는 위험을 수반하는 훈련이다.
  3. 테스트 작업으로 결함이 존재하지 않는다는 사실을 입증할 수 없다.
  4. 아래와 같은 사유로 인하여 발견한 모든 결함을 수정할 수는 없다.
  5. 발견한 결함이 많을 수록 남아 있는 결함의 수도 많다.

* 소프트웨어 테스터

  * 역할
    * 결함을 가능한 한 빨리 발견하여 결함이 수정 보완 되었는지 확인
  * 능력
    * 탐구심, 문제 해결력, 창의력, 적당한 수준의 완벽성, 재치와 능숙함, 설득력

* 결함 조치 우선 순위 결정 절차

  * 업무별 기준에 가중치를 부여
  * 단위 업무와 연결하여 심각도를 계산
  * 위 둘을 고려하여 우선 순위를 결정

* 프로그램 코드 검토 기법: 개발 과정의 중간 산출물을 점검하여 결함을 발견하려는 기법

  * 개별 검토(Self Review)
    * 가장 간단한 검토의 형태
    * 스스로 결함을 검토하므로 객관성이 낮음
  * 동료 검토(Peer Review, Buddy Checks)
    * 비공식적 검토 방법
    * 검토 절차가 비교적 간단, 개발팀 내의 동료가 검토하여 개별 검토에 비해 상대적으로 객관성이 높음
  * 워크스루(Walkthrough)
    * 검토회의라고 하며 검토 전문가 요원들이 미리 정해진 절차와 준비 과정에 따라 개발자의 코드와 산출물을 검토하는 방법
    * 작업 결과의 객관성을 확보할 수 있어 중간 산출물에 대한 작업 완료 기준으로 삼을 수 있음

* 소프트웨어 인스펙션(Software Inspection, =소프트웨어 검사)

  * 워크스루를 보안하여 검토 후 발견된 문제점들을 수정할 지침까지 지원하는 검토 기법

  * 개발자와 논의 없이 검사하는 작업

  * 코드 인스펙션 외에도 설계 및 설계 산출물까지 포괄함

  * 코드 인스펙션, 워크스루와 같이 몇 시간 동안 수행되는 단위 검토 방법과 구별되어야 함

  * 코드 인스펙션의 프로세스와 수행 내용

    |   구분    |              수행 단계               |                         주요 내용                         |
    | :-------: | :----------------------------------: | :-------------------------------------------------------: |
    | 자동 수행 |     1. 범위 계획(Capacity Plan)      |          인스펙션의 범위와 범위 선정 기준을 결정          |
    |           |          2. 시작(Overview)           |                    자동 인스펙션 수행                     |
    | 준비 단계 |         3. 준비(Preparation)         | 계획서 작성, 체크리스트 작성, 계획 공지, 대상 산출물 준비 |
    | 이행 단계 | 4. 인스펙션 회의(Inspection Meeting) |                 사전 검토 실시, 미팅 실시                 |
    | 시정 조치 |          5. 재작업(Rework)           |                  개발 원작자가 직접 작업                  |
    |           |       6. 후속 처리(Follow-up)        |                 결과 분석서 작성 및 보고                  |

  * 인스펙션을 해야 하는 비즈니스적인 이유

    * 결함의 초기 발견 시 수정(fix) 비용 감소
    * 인스펙션의 데이터를 통해 업무에 집중 가능
    * 교차 교육 가능
    * 제품의 're-engineering'이 가능한 영역을 식별
    * 소프트웨어를 개발하고 유지하는데 비용 감소
    * 스케줄에 긍정적인 효과
    * 품질 향상

  * 인스펙션과 워크스루의 차이점

    |         구분         |              인스펙션               |            워크스루             |
    | :------------------: | :---------------------------------: | :-----------------------------: |
    |         목적         |          결함 파악 및 제거          |       산출물 평가 및 개선       |
    |      수행 조건       |       완성도가 기준 이상일 때       |     팀이나 관리자의 필요시      |
    |    결함 수정 여부    |      모든 결함은 제거되어야 함      |            저자 결정            |
    |    변경 사항 검증    |      진행자가 재작업 결과 확인      |            저자 결정            |
    |     검토자 인원      |                3~6명                |              2~7명              |
    |        참여자        |                동료                 |       기술 전문가 및 동료       |
    |     검토 인도자      |     교육 받은 진행자(Moderator)     |              저자               |
    |    검토 준비 여부    |      체크리스트를 이용한 검토       | 일반적으로 검토를 준비하지 않음 |
    |      검토 분량       |           상대적으로 적음           |         상대적으로 적음         |
    |      검토 속도       |           상대적으로 느림           |              빠름               |
    |        발표자        | 산출물에 의존도가 높은 사람(Reader) |              저자               |
    |    지표 수집 여부    |       모든 검토자들이 기록함        |            하지 않음            |
    |        보고서        |      결함 리스트 및 측정 지표       |         워크스루 보고서         |
    |   데이터 측정 여부   |                필수                 |            권장사항             |
    | 체크리스트 사용 여부 |               사용함                |          사용하지 않음          |

* 소프트웨어 형상 관리(SCM: Software Configuration Management)

  * 형상 관리

    * 소프트웨어 프로세스 전반에 걸쳐 소프트웨어 형상의 변경 요인에 대해 소프트웨어 형상을 체계적으로 추적하고 보호하는 활동

    * 개발 과정 전 단계에서 형상 관리를 함으로써 소프트웨어 개발의 전체 비용을 줄임, 문제점 발생 요인이 최소화 되도록 보증하는 것을 목표로 함

    * 변경 사항을 파악하고 제어하여, 적절히 변경되고 있는지에 대해 확인하여 해당 담당자에게 통보

    * 변경 관리나 버전 관리 모두 형상 관리에 포함

    * 주요기능: 형상을 식별하고 관리

    * 일반적으로 형상 식별, 버전 관리, 변경 통제, 형상 감사, 상태 보고 등의 활동으로 이루어짐

    * 형상 식별자 항목: 이름, 서술, 자원, 실현

      |   단계    |                           설명                           |
      | :-------: | :------------------------------------------------------: |
      | 형상 식별 |   형상 관리 대상을 구분하고 고유한 관리 목록 번호 부여   |
      | 버전 관리 | 진화 그래프 등을 통해 SCI의 버전 부여 및 갱신(버전 제어) |
      | 변경 통제 |        SCI에 대한 접근 및 동기화 제어(변경 관리)         |
      | 형상 감사 |          SCI 무결성을 평가하여 공식적으로 승인           |
      | 상태 보고 | 개발자와 유지 보수 담당자에게 변경사항을 공지(형상 기록) |

  * 기준선(Baseline)

    * 변경을 통제하게 도와주는 기준선은 정식으로 검토 및 합의된 명세서나 제품 개발의 바탕으로서, 정식의 변경 통제 절차를 통해서만 변경 가능

  * 소프트웨어 형상 항목(SCI: Software Configuration Item)

    * 소프트웨어 형상과 개발 도구의 합성

    * 개발 단계별로 기준선을 기준으로 형상 항목을 관리

      |      개발 단계      |                      기준선(Baseline)                      |                     소프트웨어 형상 항목                     |
      | :-----------------: | :--------------------------------------------------------: | :----------------------------------------------------------: |
      |        계획         |                      사용자 요구 사항                      | 시스템 명세서, 개발 계획서, 구성 관리 계획서<br />, 품질 평가 계획서, 개발 표준 및 철자 매뉴얼 |
      |      요구 분석      | 사용자 요구 기능이 하위 시스템 간에 어떻게 분배되는가 여부 |          자료 흐름도, 자료 사전, 자료 흐름도 명세서          |
      |        설계         |                     개발 전 설계 명세                      | 입출력 명세서, 화면 설계서, 초기 사용자 매뉴얼<br />, 초기 시스템 매뉴얼, 자료 구조도, 시스템 구조도 |
      |        구현         |                        시험 계획서                         |        원시코드, 목적코드, 실행코드, 단위 시험 보고서        |
      | 시스템 통합 및 시험 |                            제품                            | 통합 시험 보고서, 기능/성능/과부하 시험 보고서<br />, 인증 시험 보고서 |
      |    설치 및 운영     |                            운영                            |         목적/실행코드, 운영자 매뉴얼, 사용자 매뉴얼          |

  * 형상 관리 도구(Configuration Management Tool)

    * 각 단계에서의 산출물의 변경사항을 버전별로 관리하여 목표 시스템의 품질 향상을 지원하는 도구

    * 주 기능: check-out, check-in, commit, update, import, export

      |         형상 관리 도구         |                             설명                             |
      | :----------------------------: | :----------------------------------------------------------: |
      | CVS(Concurrent Version System) | - 무료 서버/클라이언트 형상 관리 시스템<br />- 파일 관리나 커밋 중 오류 시 롤백이 되지 않아 SVN으로 대체됨<br />- 단순한 명령 구조를 가진 장점, 텍스트 기반의 코드만 지원하는 단점 |
      |        SVN(Subversion)         | - CVS의 단점을 보완하기 위해 만들어진 소프트웨어, 중앙관리만 지원<br />- 다양한 GUI 도구가 존재<br />- gzip 압축을 통해 서버의 공간을 절약하는 장점, trunk, branch, tag가 모두 저장 위치를 점유하는 단점 |
      |              Git               | - 리눅스 커널의 개발을 위해 만든 분산 버전 관리 시스템<br />- 장소에 구애 받지 않고 협업이 가능, 로컬에 저장이 가능하기 때문에 오프라인 작업이 가능<br />- CVS와 SVN의 단점을 모두 보완한 장점, CVS와 SVN과는 개념이 달라 개발자에게 학습할 시간이 필요 |

## 4. SQL 활용

#### 1. 기본 SQL 작성하기

* SQL(Structured Query Language)

  * 관계 데이터베이스에서 사용되는 대표적인 언어
  * 고급 데이터베이스 언어
  * 대화식
  * 시작부터 ~ ';'까지가 하나의 문장

* 정의어(DDL): 테이블, 스키마, 도메인, 인덱스, 뷰 등을 정의(생성)하거나 수정, 제거하기 위해 사용되는 언어

  * CREATE 문

    * 테이블, 스키마, 도메인, 인덱스, 뷰 등을 정의(생성)하기 위해 사용

    * 테이블 생성 예제

      1. 학번, 성명, 학과, 학년, 학점으로 구성된 학생 테이블을 만듬
      2. 학번과 학년은 숫자형 자료이며, 나머지는 문자형
      3. 학번을 기본키로 지정
      4. 성명 속성은 공백이 있을 수 없음
      5. 학과 항목을 이용하여 [수강] 테이블의 학과를 참조하도록 외래키를 지정, 참조 테이블에서 삭제가 발생하면 NULL 값으로 하고, 수정이 발생하면 연쇄적으로 수정하도록 함
      6. 학년의 속성 값은 4 이하의 값을 갖도록 'haK' 이름으로 제약

      ```mysql
      CREATE TABLE 학생
       (학번 INT,
        성명 CHAR(5) NOT NULL,
        학과 CHAR(10),
        학년 INT,
        학점 CHAR(1),
        PRIMARY KEY(학번),
        FOREIGN KEY(학과) REFERENCES 수강(학과)
        	ON DELETE SET NULL
        	ON UPDATE CASCADE,
        CONSTRAINT hak CHECK(학년 <= 4));
      ```

    * 스키마 생성 예제: 시스템 관리자가 일반 사용자에게 스키마에 대한 권한을 주기 위한 스키마를 만들기 위해 사용

      * 스키마 이름이 'JUNGBO' 이고, 허가권자가 '이영진' 인 스키마를 정의하시오.

      ```mysql
      CREATE SCHEMA JUNGBO AUTHORIZATION 이영진;
      ```

    * 도메인 생성 예제

      * 속성의 값으로 'T'와 'F' 로만 구성되는 'success' 라는 이름의 도메인을 정의하시오.(단, 속성 값이 입력되지 않을 경우 기본 값은 'T' 로 한다)

      ```mysql
      CREATE DOMAIN success CHAR(1)
       DEFAULT 'T'
       CONSTRAINT success CHECK(VALUE IN('T','F'));
      ```

    * 인덱스 정의 예제

      * [학생] 테이블의 학과 속성 값을 오름차순 정렬하여, 중복을 허용하지 않도록 'stud_idx'라는 이름의 인덱스를 정의하시오.

        ```mysql
        CREATE UNIQE INDEX stud_idx
         ON 학생(학과 ASC);
        ```

  * ALTER 문

    * 기존에 만들어진 테이블에 새로운 속성(항목)을 추가(ADD)하거나 기존 속성을 변경(ALTER), 삭제(DROP)할 때 사용

    * 예제

      * [학생] 테이블에 '주소' 속성을 추가하시오(단, 주소 항목은 가변길이 문자형으로 30자까지 입력될 수 있다)

        ```mysql
        ALTER TABLE 학생 ADD 주소 VARCHAR(30);
        ```

      * [학적] 테이블에서 '학년' 속성을 제거하시오

        ```mysql
        ALTER TABLE 학적 DROP 학년 CASCADE;
        ```

  * DROP 문

    * 테이블, 스키마, 도메인, 인덱스, 뷰, 제약조건 등을 제거할 때 사용, 삭제 시 테이블 전체가 삭제

    * 예제

      * [학적] 테이블을 삭제하시오

        ```mysql
        DROP TABLE 학적 CASCADE;
        ```

  * RESTRICT: 삭제할 요소가 참조(사용) 중이면 삭제가 이루어지지 않음

  * CASCADE: 삭제할 테이블을 참조 중인 다른 테이블도 연쇄적으로 같이 삭제

* 조작어(DML)

  * 데이터베이스 내의 자료를 실제 사용자가 이용(조작)하기 위한 언어

  * SELECT(검색문)

    * 원하는 자료를 검색하고자 하는 경우에 사용, 산술식에 의한 계산도 수행

    * 일반적인 조건은 WHERE 절을 이용, GROUP BY에 의한 그룹 조건은 HAVING 절을 이용

    * 단순 질의문 예제

      * [학생] 테이블에서 학년이 '3' 이고, 수강과목이 '산업공학' 인 학생의 성명과 연락처를 검색하시오.

        ```mysql
        SELECT 성명, 연락처
        FROM 학생
        WHERE 학년=3 AND 수강과목='산업공학';
        ```

    * 'DISTINCT' 옵션을 이용하여 중복된 값을 제거한 검색 예제

      * [학생] 테이블에서 2학년 이상인 학생의 수강과목을 검색하되, 같은 수강과목 값은 한 번만 검색되도록 하시오

        ```mysql
        SELECT DISTINCT 수강과목
        FROM 학생
        WHERE 학년>=2;
        ```

    * 함수를 이용한 검색문 예제

      * [학생] 테이블에서 3학년 학생의 점수 합계를 '3학년합계' 라는 속성 이름으로 구하시오.

        ```mysql
        SELECT SUM(점수) AS 3학년합계
        FROM 학생
        WHERE 학년=3;
        ```

    * 검색된 결과를 정렬해서 표현하고자 하는 경우 예제

      * [학생] 테이블에서 점수가 85점 이상인 학생을 학번의 오름차순으로 성명을 검색하시오.

        ```mysql
        SELECT 학번
        FROM 학생
        WHERE 점수>=85
        ORDER BY ASC;
        ```

    * 그룹 분류 질의문 예제

      * [학생] 테이블에서 2명 이상인 학년을 검색하시오.

        ```mysql
        SELECT 학년
        FROM 학생
        GROUP BY 학년
        HAVING COUNT(*)>=2;
        ```

    * 부속(하위) 질의문 예제

      * [학생정보] 테이블과 [학과인원] 테이블을 이용하여 '오승윤' 학생이 속한 학과의 학생수를 검색하시오.

        ```mysql
        SELECT 학생수
        FROM 학과인원
        WHERE 학과 = 		# 검색 결과가 하나면 = 사용
        	(SELECT 학과
        	FROM 학생정보
        	WHERE 이름='오승윤');
        ```

      * [학생정보] 테이블과 [학과인원] 테이블을 이용하여 학과 학생수가 30명 이하인 학과 학생의 이름을 검색하시오

        ```mysql
        SELECT 이름
        FROM 학생정보
        WHERE 학과 IN		# 검색 결과가 여러개면 IN 사용
        	(SELECT 학과
        	FROM 학과인원
        	WHERE 학생수<=30);
        ```

    * 부분 매치 질의문 예제

      * [학생] 테이블에서 연락처의 번호가 '7588' 로 끝나는 학생의 성명을 검색하시오.

        ```mysql
        SELECT 성명
        FROM 학생
        WHERE 연락처 LIKE '%7588';		# 여러 문자를 대신하는 '%'나 한 자리를 대신하는 '_' 를 사용하면 '=' 대신 LIKE 사용
        ```

    * 'NULL' 값과 비교하는 질의문 예제

      * [학생] 테이블에서 연락처가 NULL이 아닌 학생의 성명을 검색하시오.

        ```mysql
        SELECT 성명
        FROM 학생
        WHERE 연락처 IS NOT NULL;	# NULL 과 비교할 때는 'IS' 나 'IS NOT' 을 사용
        ```

  * INSERT(삽입문)

    * 기존 테이블에 새로운 자료(튜플)를 삽입하는 경우

      * [학생] 테이블에 학번 951115, 성명 '김정미', 학년 4, 수강과목 '데이터베이스', 연락처 '243-0707' 인 학생을 삽입하시오.

        ```mysql
        INSERT INTO 학생(학번, 성명, 학년, 수강과목, 연락처)		# 모든 속성값을 가지고 있으면 괄호 안에 있는 내용 생략 가능
        VALUES (951115, '김정미', 4, '데이터베이스', '243-0707');
        ```

  * UPDATE(갱신문)

    * 테이블의 자료(튜플) 중에서 값을 변경하고자 하는 경우 사용

      * [학생] 테이블에서 '오준석' 학생의 점수를 92점으로 수정하시오.

        ```mysql
        UPDATE 학생
        SET 점수=92
        WHERE 성명='오준석';
        ```

  * DELETE(삭제문)

    * 테이블의 자료(튜플)를 삭제할 경우 사용

    * WHERE 절을 생략하면 모든 튜플이 삭제되어 빈 테이블이 됨

      * [학생] 테이블에서 2학년 학생의 자료를 삭제하시오.

        ```mysql
        DELETE FROM 학생
        WHERE 학년=2;
        ```

      * [학생] 테이블의 모든 학생을 삭제하시오.

        ```mysql
        DELETE FROM 학생
        ```

* 제어어(DCL)

  * 관리자가 데이터의 보안, 무결성 유지, 병행제어, 회복 등을 하기 위해 사용하는 언어

  * COMMIT

    * 연산에 의한 수정 내용을 지속적으로 유지

      * [학생] 테이블에서 김길동 학생의 연락처를 '232-0077'로 갱신하시오.

        ```mysql
        UPDATE 학생 SET 연락처='232-0077' WHERE 성명='김길동';
        COMMIT;
        ```

  * ROLLBACK

    * 수행되기 이전 상태로 되돌리기 위해 연산 내용을 취소

      ```mysql
      DELETE FROM 학생 WHERE 성명='최길동';
      ROLLBACK;
      ```

      * ↑최길동 학생의 자료를 삭제하고 ROLLBACK 명령에 의한 연산이 취소되어 삭제된 자료가 되살아남

  * GRANT

    * 관리자가 사용자에게 데이터베이스에 대한 권한을 부여

    * `GRANT 권한내용(A) ON 테이블_이름(B) TO 사용자(C) [WITH GRANT OPTION];`

      * 관리자가 사용자C에게 테이블B에 대한 권한 A를 부여

      * WITH GRANT OPTION: 사용자가 부여 받은 권한을 다른 사용자에게 부여할 수 있는 권한 부여권까지 부여

      * 관리자가 사용자 OTH에게 [학생] 테이블에 대해 UPDATE 할 수 있는 권한과 그 권한을 필요시 다른 사용자에게 부여할 수 있는 권한을 부여하시오

        ```mysql
        GRANT UPDATE ON 학생 TO OTH WITH GRANT OPTION;
        ```

  * REVOKE

    * 관리자가 사용자에게 부여했던 권한을 취소하기 위해 사용

    * `REVOKE 권한내용(A) ON 테이블_이름(B) FROM 사용자(C) [CASCADE];`

      * 사용자 OTH에게 부여했던 [학생] 테이블에 대한 UPDATE 권한을 취소하시오.

        ```mysql
        REVOKE UPDATE ON 학생 FROM OTH CASCADE;
        ```

#### 2. 고급 SQL 작성하기

* 인덱스(Index)

  * 원하는 자료를 빠르고 효율적으로 검색하기 위해서 사용하는 방법

  * 기본적으로 데이터의 위치(주소)를 관리, 기억하는 인덱스 파일과 실제 데이터를 기억하는 데이터 파일로 구성

  * 기본키 속성으로 만든 인덱스를 '기본 인덱스(Primary Index)', 일반 속성으로 만든 인덱스를 '보조 인덱스(Secondary Index)' 라함

    ```mysql
    CREATE UNIQUE INDEX Stud_idx
    ON 학생(학번 ASC);
    ```

    

    |                             장점                             |                             단점                             |
    | :----------------------------------------------------------: | :----------------------------------------------------------: |
    | - 데이터 검색 속도의 향상<br />- 시스템 부하 감소<br />- 시스템 전체의 성능 향상 | - 추가 DB 공간 필요<br />- 인덱스 생성 시간 소요<br />- 잦은 변경작업(Insert, Update, Delete)으로 인한 성능 저하 |

  * 구조

    * B -트리(Balanced Tree)

      * 하나의 노드에는 여러 개의 자료를 기억할 수 있음

      * 루트(Root) 노드와 리프(Leaf) 노드를 제외한 노드에는 한 노드에 반절 이상의 자료가 채워져야 함

        * 차수: 노드의 가짓수
        * 루트 노드: 트리에서 최상위 노드
        * 리프 노드: 단말 노드라고도 하며, 하위 노드가 없는 노드

      * 모든 리프(단말) 노드는 같은 레벨에 있음

      * 루트 노드는 리프 노드가 아닌 이상 적어도 두 개의 서브트리를 갖음

      * 한 노드 안에 있는 키 값들은 오름차순으로 구성

      * 검색은 루트 노드에서부터 시작

      * 탐색 트리

        * 루트 값과 비교하여 루트보다 작은 값은 좌측 서브트리로 이동하고, 루트보다 큰 값은 우측 서브트리로 이동하면서 검색하도록 만든 트리

        ![B-트리](https://user-images.githubusercontent.com/75933619/120969760-8338c880-c7a5-11eb-8836-037c009211db.png)

    * B+ -트리

      * B트리의 변형으로 인덱스 세트와 순차 세트로 구성

      * 인덱스 세트는 단말 노드를 찾기 위한 인덱스를 제공

      * 순차 세트는 단말 노드로만 구성

      * 순차 세트의 단말 노드에는 모든 키 값이 다시 나타나도록 하여 단말 노드만으로도 순차 검색이 가능

        ![B+트리](https://user-images.githubusercontent.com/75933619/120969785-8cc23080-c7a5-11eb-84e8-7b180cde3da1.png)

    * 클러스터드 인덱스(Clustered Index)

      * 테이블에서 하나의 속성을 기준으로 정렬 시킨 후, 테이블을 재구성하여 인덱스를 만드는 방법

      * 테이블의 물리적 순서(실제 순서)와 인덱스 순서가 동일

      * 하나의 테이블에는 하나의 인덱스만 만들 수 있음

        ![클러스터드 인덱스](https://user-images.githubusercontent.com/75933619/120969821-99468900-c7a5-11eb-9d89-48b8e7d369a3.png)

    * 넌 클러스터드 인덱스(Non Clustered Index)

      * 테이블을 재구성하지 않고, 테이터 주소를 이용하여 인덱스를 만들어 주소 값을 이용하여 검색하는 방법

      * 하나의 테이블에 여러 개의 인덱스를 만들 수 있음

      * 인덱스 구조보다 다소 복잡해질 수 있음

        ![넌클러스터드 인덱스](https://user-images.githubusercontent.com/75933619/120969862-a5cae180-c7a5-11eb-925b-d733e00b1e83.png)

    > * 클러스터드 인덱스는 실제 데이터의 순서와 인덱스의 선서가 일치하기 때문에 일정한 범위를 가지고 찾는 경우 속도 향상에 도움이 됨
    >
    > * 클러스터드 인덱스는 삽입, 수정의 경우 변경된 내용을 인덱스에 반영하고 재정렬해야 하므로 넌 클러스터드 인덱스보다 불리함
    > * 넌 클러스터드 인덱스는 한 개의 특정 값을 찾거나, 많은 양의 데이터 중에서 작은 범위를 찾을 때 유용

  * 인덱스 정의어

    > 표준 SQL에 포함되지 않아 DBMS 제품마다 구문이 약간 씩 다름

    * 인덱스 생성

      * 테이블에 있는 하나 이상의 속성(컬럼)으로 만들 수 있음

      * [학생] 테이블의 학과 속성값을 오름차순 정렬하여, 중복을 허용하지 않도록 'stud_idx'라는 이름의 인덱스를 생성하시오

        ```mysql
        CREATE UNIQE INDEX stud_idx ON 학생(학과 ASC);
        ```

      * [회원] 테이블의 회원명 속성값과 주소 속성값을 이용하여, 중복을 허용하지 않도록 'member_idx'라는 이름의 인덱스를 생성하시오

        ```mysql
        CREATE UNIQE INDEX member_idx ON 회원(회원명, 주소);
        ```

    * 인덱스 제거

      * 보통 DROP INDEX문에 의해 제거

      * ALTER TABLE 명령 뒤에 DROP INDEX 명령이 추가되는 형태로도 사용

      * 일반적으로 인덱스가 테이블에 종속되어 존재하기 때문에 인덱스를 제거하기 위해서는 테이블의 변경 후, 인덱스를 제거하게 됨

      * 'stud_idx'라는 이름의 인덱스를 제거하시오

        ```mysql
        DROP INDEX stud_idx;
        ```

    * 인덱스 수정

      * 인덱스는 ALTER INDEX문에 의해 재생성됨, 즉, 기존 인덱스를 삭제하고 다시 생성하게 됨

      * 최초에 생성된 인덱스를 수정하는 경우는 매우 드뭄, 일부 DBMS에서는 수정하는 SQL문을 지원하지 않음

      * [학생] 테이블의 학과 속성값을 내림차순 정렬하여, 중복을 허용하지 않도록 'stud_idx'라는 이름의 인덱스를 수정하시오

        ```mysql
        ALTER UNIQUE INDEX stud_idx ON 학생(학과 DESC);
        ```

  * 인덱스 스캔(Index Scan) 방식

    * 구분 기준
      * 속성값의 유일성
        * unique, non-unique
      * 속성의 수
        * 단일 인덱스, 결합 인덱스
      * 물리적 구성 방식
        * B* Tree, 비트맵(Bitmap), 클러스터
    * 일반적으로 밸런스트 트리 인덱스(B* Tree)를 사용

* 뷰(VIEW)

  * 하나 이상의 테이블로부터 유도되어 만들어진 가상 테이블

  * 물리적으로 기억 공간을 차지하지 않음, 논리적 독립성을 제공하고, 데이터 접근제어로 보안성을 향상

  * 뷰의 생성

    * [학생] 테이블에서 3학년 학생의 학번과 성명, 연락처 속성을 이용하여 학번, 이름, 전화번호 속성으로 구성된 '3학년연락처' 뷰를 생성하시오

      ```mysql
      CREATE VIEW 3학년연락처(학번, 이름, 전화번호)
      AS SELECT 학번, 성명, 연락처
      FROM 학생
      WHERE 학년=3;
      # WITH CHECK OPTION: 뷰에 대한 갱신, 삽입, 수정 등의 연산 시 WHERE 절의 조건에 맞지 않으면 실행이 되지 않도록 하는 옵션
      ```

  * 뷰의 삭제

    * 위에서 생성한 '3학년연락처' 뷰를 제거하고, 연관된 뷰들도 연쇄적으로 제거하시오

      ```mysql
      DROP VIEW 3학년연락처 CASCADE;
      ```

  * 뷰의 특징

    * 뷰가 정의된 기본 테이블이 제거되면, 뷰도 자동적으로 제거됨
    * 뷰에 대한 검색(SELECT)은 일반 테이블과 거의 동일
    * 뷰에 대한 삽입, 삭제, 갱신은 제약이 따름. 뷰의 속성 중 기본 테이블의 기본키가 포함되어 있지 않으면 삽입, 삭제, 갱신이 되지 않음
    * 보안 측면에서 뷰를 활용할 수 있음
    * 뷰는 ALTER문을 이용하여 변경할 수 없음
    * 한 번 정의된 뷰는 변경할 수 없으며, 삭제한 후 다시 생성해야 함

* 시스템 카탈로그(System Catalog)(=데이터 사전)

  * 데이터베이스에 저장되어 있는 테이블, 인덱스, 뷰, 제약조건, 사용자 등 개체들에 대한 정보와 정보들 간의 관계를 저장한 것, 그 자체가 하나의 작은 데이터베이스임
  * 시스템 카탈로그에 저장된 데이터를 메타 데이터(Meta Data)라고 함
  * 일반 테이블과 같이 시스템 테이블로 구성
  * 일반 사용자도 시스템 카탈로그의 내용을 검색할 수 있지만, 내용을 삽입, 삭제, 갱신 등은 불가능
  * 시스템 카탈로그 생신은 사용자가 SQL 문을 실행하면 시스템에 의해 자동적으로 이루어짐

* 다중 테이블 검색

  * 부속(하위) 질의(=서브 쿼리(Subquery))

    * 서브 쿼리는 하나의 SELECT 문장의 절 안에 포함된 또 하나의 SELECT 문을 말함

    * 서브 쿼리를 포함하고 있는 쿼리문을 메인 쿼리(Main query), 포함된 또 하나의 쿼리를 서브 쿼리(Sub query)라 함

    * 서브 쿼리는 메인 쿼리가 실행되기 이전에 한 번만 실행

    * 서브 쿼리는 비교 연산자의 오른쪽에 기술, 반드시 소괄호() 안에서 사용

    * 서브 쿼리가 반환하는 행의 수 또는 칼럼 수는 메인 쿼리가 기대하는 행의 수 또는 칼럼 수와 일치하여야 함

    * 서브 쿼리는 ORDER BY 절을 사용하지 않음

    * 메인 쿼리의 FROM 절에 있는 컬럼명은 서브 쿼리 내에서 사용될 수 있으나, 서브 쿼리의 FROM 절에 있는 컬럼명은 메인 쿼리에서 사용할 수 없음

    * 단일 행(Single Row) 서브 쿼리

      * 서브 쿼리 수행 결과가 오직 하나의 행(로우, row)만 반환

      * 메인 쿼리의 WHERE 절에서는 단일 행 비교 연산자인 =, <>, >, >=, <, <= 를 사용

      * [성적] 테이블에서 '강희영'의 점수보다 더 높은 점수를 받은 학생을 검색하시오.

        ```mysql
        SELECT *
        FROM 성적
        WHERE 점수 > (SELECT 점수
        			 FROM 성적
        			 WHERE 성명='김영진');
        ```

    * 다중 행(Multiple Row) 서브 쿼리

      * 서브 쿼리에서 반환되는 결과가 여러 행

      * 다중 행 연산자와 함께 사용

        | 다중 행 연산자 |                             설명                             |
        | :------------: | :----------------------------------------------------------: |
        |       IN       | 메인 쿼리의 비교 조건('=' 연산자로 비교할 경우)이 서브 쿼리의 결과 중에서 하나라도 일치하면 참 |
        |   ANY, SOME    | 메인 쿼리의 비교 조건이 서브 쿼리의 검색 결과와 하나 이상이 일치하면 참 |
        |      ALL       | 메인 쿼리의 비교 조건이 서브 쿼리의 검색 결과와 모든 값이 일치하면 참 |
        |     EXISTS     | 메인 쿼리의 비교 조건이 서브 쿼리의 결과 중에서 만족하는 값이 하나라도 존재하면 참 |

      * [성적] 테이블에서 점수가 80점 이상인 학생의 학과와 같은 학과의 학생을 검색하시오.

        ```mysql
        SELECT *
        FROM 성적
        WHERE 학과 IN (SELECT 학과
        			  FROM 성적
        			  WHERE 점수 >= 80);
        ```

  * 조인(JOIN)

    * 둘 이상의 테이블로부터 특정 공통된 값을 갖는 행을 연결하거나 조합하여 검색하는 것으로 관계형 DBMS에서 매우 중요한 연산

    * SQL의 SELECT문의 FROM절에 두 개 이상의 테이블을 대상으로 조인 조건에 부합하는 조인 연산을 수행

    * DBMS 마다 조인 문법에 차이가 있음

    * 조인의 필요성: 여러 테이블에 흩어져 있는 정보 중에서 사용자가 필요한 정보를 가져와서 하나의 가상 테이블로 결과를 보여줌

    * 정규화: 릴레이션 분해

    * 조인: 릴레이션 결합

    * 조인의 종류

      |         구분          |                     조인 종류                      |                             설명                             |
      | :-------------------: | :------------------------------------------------: | :----------------------------------------------------------: |
      | 내부 조인(Inner Join) |                동등 조인(Equi Join)                |             동일 칼럼을 기준으로 조합하여 나타냄             |
      |                       |             비동등 조인(Non-Equi Join)             |         동일 칼럼이 없이 다른 조건을 사용하여 나타냄         |
      | 외부 조인(Outer Join) | Left Outer Join, Right Outer Join, Full Outer Join |            조인 조건에 만족하지 않는 행도 나타냄             |
      | 셀프 조인(Self Join)  |                                                    |               한 테이블 내에서 조인하여 나타냄               |
      | 교차 조인(Cross Join) |                                                    | 카티션 곱이라고도 부르며, 조인 조건이 생략 또는<br /> 누락되어 모든 조합 행을 나타냄 |

      * 물리적 조인: 데이터베이스 내부에서 발생하는 테이블 결합 방식으로 중첩 반복 조인, 정렬 합병 조인, 해시 조인이 있음

    * 컬럼명의 모호성 해결 방법

      * 조인 수행 시 두 테이블에 동일한 이름의 칼럼을 사용하면 오류 메시지가 출력 되고 조인을 수행하지 않음

      * SELECT 절이나 WHERE절에 "테이블명.칼럼명"으로 표현

      * 테이블 별칭을 부여하면 테이블명을 단순화할 수 있으며 FROM 절에 "테이블명 별명" 형태로 테이블명과 볆명 사이에 한 칸 이상의 공백을 띄움

        * 별명: 데이터, 칼럼, 테이블 등에 별칭을 주어 명확한 식별 및 간결성을 위해 사용
          * Oracle: SELECT S.학번 FROM 학생 S;
          * MySQL: SELECT S.학번 FROM 학생 AS S;

      * [학생] 테이블에서 성명과 학과번호를 검색하시오

        ```mysql
        SELECT 성명, 학과번호
        FROM 학생;
        ```

        ```mysql
        SELECT 학생.성명, 학생.학과번호
        FROM 학생;
        ```

        ```mysql
        SELECT S.성명, S.학과번호
        FROM 학생 S;
        ```

    * 교차 조인(Cross Join)

      * 카티션 곱이라고도 하며, WHERE 절에 JOIN 조건이 존재하지 않을 경우 JOIN에 참조되는 두 테이블의 각 행의 행수를 모두 곱한 결과의 행수로 테이블이 반환됨

      * 반환되는 결과 테이블은 두 테이블의 디그리의 랍과 카디널리티의 곱의 크기임

        * 디그리: 칼럼(속성)의 개수
        * 카디널리티: 로우(튜플)의 개수

      * 교차 조인은 단순 결합된 형태이기 때문에 조인 결과가 무의미함, 조건을 명확히 지정한 다른 조인 방법을 활용하는 것이 바람직함

      * [학생] 테이블과 [학과] 테이블을 교차 조인하는 SQL문을 작성하시오.

        ```mysql
        SELECT *
        FROM 학생, 학과;
        ```

        * ANSI SQL표준: SELECT * FROM 학생 CROSS JOIN 학과;

    * 동등 조인(Eqiu Join)

      * 가장 많이 사용하는 조인 방법

      * 두 테이블에서 공통적으로 존재하는 컬럼의 값이 일치되는 공통 행을 연결하여 결과를 생성

      * WHERE 절에 1개 이상의 조인 조건을 반드시 작성

      * [학생] 테이블과 [학과] 테이블을 동등 조인하는 SQL문을 작성하시오

        ```mysql
        SELECT *
        FROM 학생 S, 학과 D
        WHERE S.학과번호 = D.학과번호;
        ```

    * 자연 조인(Natural Join)

      * ANSI SQL표준으로 대부분의 DBMS에서 사용되는 조인 문법

      * 테이블 간의 모든 칼럼을 대상으로 공통 칼럼을 자동으로 조사하여 같은 칼럼명을 가진 값이 일치할 경우 조인 조건을 수행

      * [학생] 테이블과 [학과] 테이블을 자연 조인하는 SQL 문을 작성하시오

        ```mysql
        SELECT *
        FROM 학생 NATURAL INNER JOIN 학과;	# INNER 생략 가능
        ```

  * 집합(SET) 연산자

    * 집합 연산자의 종류

      ![집합 연산자](https://user-images.githubusercontent.com/75933619/120969973-bed39280-c7a5-11eb-8503-c7eb3126730b.png)

    * UNION 연산자

      * 합집합 연산자(중복행을 제거하고 반환)

      * [데이터베이스] 테이블과 [인공지능] 테이블을 활용하여 데이터베이스 과목과 인공지능 과목을 수강하는 학생을 검색하시오

        ```mysql
        SELECT * FROM 데이터베이스
        UNION
        SELECT * FROM 인공지능;
        ```

    * UNION ALL 연산자

      * 합집합 연산자(중복된 행을 포함하여 반환)

      * [데이터베이스] 테이블과 [인공지능] 테이블을 활용하여 데이터베이스 과목과 인공지능 과목을 수강하는 학생을 검색하시오(단, 중복된 결과 행을 모두 포함한다)

        ```mysql
        SELECT * FROM 데이터베이스
        UNION ALL
        SELECT * FROM 인공지능;
        ```

    * INTERSECT 연산자

      * 교집합 연산자

      * MySQL 에서는 교집합 연산자가 없음

      * [데이터베이스] 테이블과 [인공지능] 테이블을 활용하여 데이터 베이스 과목과 인공지능 과목을 동시에 수강하는 학생을 검색하시오.(Oracle의 경우)

        ```mysql
        SELECT * FROM 데이터베이스
        INTERSECT
        SELECT * FROM 인공지능;
        ```

    * MINUS 연산자

      * 차집합 연산자

      * Oracle 에서는 MINUS, SQL Server에서는 EXCEPT 연산자를 각각 사용

      * MySQL 에서는 차집합 연산자가 없음

      * [데이터베이스] 테이블과 [인공지능] 테이블을 활용하여 인공지능 과목은 수강하지 않고 데이터베이스 과목만 수강하는 학생을 검색하시오.(Oracle의 경우)

        ```mysql
        SELECT * FROM 데이터베이스
        MINUS
        SELECT * FROM 인공지능;
        ```

        
